Q)What is the difference between POJO class and Java Bean class?

POJO
====
POJO stands for Plain Old Java Object.

A class is said to be pojo class if it supports following two properties.

1) All variables must be private.

2) All variables must and setter and getter methods.

Java Bean
==========
A class is said to be java bean class if it supports following four properties.

1)A class should be public.

2)A class should have atleast zero argument constructor

3)All variables must be private 

4)All variables must have setter and getter methods.

Note:
-----
Every java bean class is a pojo class but every pojo class is not a java bean class.


Method overloading
==================
Having same method name but different parameters in a single class is called 
method overloading.

Methods which are present in a class are called overloaded methods.

Method overloading will reduce complexity of the programming.

ex:

class MeeSeva
{
	//overloaded methods 
	public void search(int voterId)
	{
		System.out.println("Details Found By voterId");
	}
	public void search(String houseNo)
	{
		System.out.println("Details Found By houseNo");
	}
	public void search(long aadharCard)
	{
		System.out.println("Details Found By aadharCard");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		MeeSeva ms=new MeeSeva();
		ms.search(101);
		ms.search("1-5/4/1");
		ms.search(1012l);
	}
}

Method overriding
==================
Having same method name with same parameters in two different classes is called method 
overriding.

Methods which are present in parent class are called overridden methods.

Methods which are present in child class are called overriding methods.

ex:
---

class Parent 
{
	public void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	//overridden methods 
	public void marry()
	{
		System.out.println("Subhalakshmi");
	}
}
class Child extends Parent 
{
	//overriding methods 
	public void marry()
	{
		System.out.println("Trisha/Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p=new Parent();
		p.property();//cash+gold+land
		p.marry();//subhalakshmi

		Child c=new Child();
		c.property();//cash+gold+land
		c.marry();//Trisha/Rashmika

		Parent p1=new Child();
		p1.property();//cash+gold+land
		p1.marry();//Trisha/Rashmika


	}
}

If we declare any methods as final then overriding of that method is not possible.

ex:

class Parent 
{
	public void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	//overridden methods 
	public final void marry()
	{
		System.out.println("Subhalakshmi");
	}
}
class Child extends Parent 
{
	//overriding methods 
	public void marry()
	{
		System.out.println("Trisha/Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p=new Parent();
		p.property();//cash+gold+land
		p.marry();//subhalakshmi

		Child c=new Child();
		c.property();//cash+gold+land
		c.marry();//Trisha/Rashmika

		Parent p1=new Child();
		p1.property();//cash+gold+land
		p1.marry();//Trisha/Rashmika


	}
}

Method Hiding
=============
Method hiding is exactly the same as method overriding with following differences.

Method overriding				Method hiding
--------------------				--------------
All the methods present in method overriding	All the methods present in method hiding
must be non-static.				must be static.

Method resolution will taken care by 		Method resolution will taken care by 
JVM based on runtime object.			compiler based on reference type.

It is also known as runtime polymorphism,	It is also known as compile time polymorhpism
dynamic polymorphism or late binding.		,static polymorphism or early binding.

ex:
---
class Parent 
{
	public static void property()
	{
		System.out.println("Cash+Gold+Land");
	}
	public static void marry()
	{
		System.out.println("Subhalakshmi");
	}
}
class Child extends Parent 
{
	public static void marry()
	{
		System.out.println("Trisha/Rashmika");
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Parent p=new Parent();
		p.property();//cash+gold+land
		p.marry();//subhalakshmi

		Child c=new Child();
		c.property();//cash+gold+land
		c.marry();//Trisha/Rashmika

		Parent p1=new Child();
		p1.property();//cash+gold+land
		p1.marry();//Subhalakshmi


	}
}

Interview Questions
==================

Q)Can we overload main method in java?

Yes, it is possible to overload main method in java but JVM always execute main method with
String[] parameter only.
ex:

class Test 
{
	public static void main(int[] iargs)
	{
		System.out.println("int-parameter");
	}
	public static void main(String[] args)
	{
		System.out.println("string-parameter");
	}
}

Q)Can we override main method in java?

No, we can't override main method in java because it is static and static methods can't be 
override.

Polymorphism
=============
Polymorphism has taken from Greek Word.

Here poly means many and morhpism means forms.

The ability to represent in different forms is called polymorphism.

The main objective of polymorphism is to provide flexibility.

Diagram: java25.1

In java polymorphism is divided into two types.

1) Compile time polymorphism / Static polymorphism / Early binding

2) Runtime polymorphism / Dynamic polymorphism / Late binding 

1) Compile time polymorphism
-----------------------------
A polymorphism which exhibits at compile time is called compile time polymorphism.
ex:
	Method overloading
	Method Hiding 

2)Runtime polymorphism
-------------------------
A polymorphism which exhibits at runtime is called runtime polymorphism.
ex:
	Method overriding


Summary Diagram
----------------
Diagram: java25.2


Constructors
=============
Contructor is a special method which is used to initialized an object.
ex:
	Test t=new Test();

Having same name as class name is called constructor.

A constructor does not allow any returntype.

A constructor will execute when we create an object.

A constructor will accept following modifiers.
ex:
	default
	public
	private
	protected

In java, we have two types of constructors.

1)Userdefined constructor 

2)Default constructor 

1)Userdefined constructor 
-------------------------
A constructor which is created by the user based on the application requirement is 
called userdefined constructor.

In java userdefined constructor is divided into two types.

i) Zero-argument constructor

ii) Parameterized constructor 

i) Zero-argument constructor
-------------------------
Suppose if we are not passing any argument to userdefined constructor then such constructor
is called 0-arg constructor.

ex:1
---
class Test 
{
	//constructor
	Test()
	{
		System.out.println("0-arg const");
	}
	public static void main(String[] args)
	{
		System.out.println("main method");
	}
}
o/p:
	main method

ex:2
------
class Test 
{
	//constructor
	Test()
	{
		System.out.println("0-arg const");
	}
	public static void main(String[] args)
	{
		System.out.println("main method");
		Test t=new Test();
	}
}
o/p:
	main method
	0-arg const

ex:3
---
class Test 
{
	//constructor
	public Test()
	{
		System.out.println("0-arg const");
	}
	public static void main(String[] args)
	{
		Test t1=new Test();
		System.out.println("main method");
		Test t2=new Test();
	}
}
o/p:
	0-arg const 
	main method
	0-arg const 

ii)Parameterized constructor
----------------------------
Suppose if we are passing atleast one argument to userdefined constructor then such constructor
is called parameterized constructor.

ex:

class Employee
{
	//current class variables
	private int empId;
	private String empName;
	private double empSal;

	//constructor
	protected Employee(int empId,String empName,double empSal)
	{
		this.empId=empId;
		this.empName=empName;
		this.empSal=empSal;
	}

	//display the data
	public void getEmployeeDetails()
	{
		System.out.println("Employee Id :"+empId);
		System.out.println("Employee Name :"+empName);
		System.out.println("Employee Salary :"+empSal);
	}
}
class Test 
{
	public static void main(String[] args)
	{
		Employee e=new Employee(101,"Alan Morries",10000d);
		e.getEmployeeDetails();
	}
}










































































































































































































































































